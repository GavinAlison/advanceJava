#  JVM运行时内存划分
> https://www.jianshu.com/p/a7ca8e3e15c0

在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：

![运行时内存分布](https://upload-images.jianshu.io/upload_images/3130736-f8b1f761d61b1e42?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)

线程共享：
heap、方法区(运行时常量池)

heap 中还有class字符， 里面还有字符常量池， class对象，对象头，字段信息，方法信息

线程独有：
虚拟栈、本地方法栈、程序计数器

虚拟栈： 本地局部表、操作栈、动态链接、返回地址
程序计数器： 存储的是指令的地址，以便知道执行到哪条指令与下条需要执行的指令
本地方法栈： native方法

## 虚拟机栈（JVM Stack）：
程序运行时，数据才会在这里出现.
一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame）。
栈帧中存储的有 局部变量表、操作数栈、动态链接、方法出口 等信息。
当方法被调用时，栈帧在虚拟机栈中入栈，当方法执行完成时，栈帧出栈。

局部变量表 中存储着方法的相关局部变量。
包括各种 基本数据类型，对象的引用，返回地址（returnAddress类型）等。
在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，
一个Slot就是32个bit），其它都是1个Slot。
需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中
是完全确定的，在方法的生命周期内都不会改变。

虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，
则抛出StatckOverFlowError（栈溢出）；
不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，
所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。

## 本地方法栈（Native Method Statck）
本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同。

唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行Native方法的，
在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。

与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和 OutOfMemoryError异常。

## 堆（Heap）
线程共享。

在JVM所管理的内存中，堆是最大的一块，堆也是Java GC机制所管理的主要内存区域，
堆由所有线程共享，在虚拟机启动时创建。

堆的存在的唯一目的就是为了存放对象实例。原则上讲，
所有的对象实例以及数组都在堆上分配内存（不过现代技术里，也不是这么绝对的，
也有栈上直接分配的）。

堆可以分为：新生代和老年代。
再细致一点可分为：Eden空间、From Survivor空间、To Survivor空间。

根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），
在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。






